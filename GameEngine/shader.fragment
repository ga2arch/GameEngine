#version 330

struct LightProperty {
    bool is_enabled;
    bool is_local;
    bool is_spot;
    
    vec3 pos;
    vec3 dir;
    vec3 ambient;
    vec3 color;
    vec3 half_vector;
    
    vec3 irradiance;
    float spot_umbra;
    float spot_penumbra;
    float spot_exp;
    float constant_attenuation;
    float linear_attenuation;
    float quadratic_attenuation;
};

struct MaterialProperty {
    vec3 emission;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
    
    vec3 kd;
    float ks;
};

uniform LightProperty lights[1];
uniform MaterialProperty material;

uniform vec3 camera;
uniform mat4 view;
uniform mat4 light_view;

uniform sampler2D p_tex;
uniform sampler2D n_tex;
uniform sampler2D w_tex;

uniform sampler2DShadow shadow_map;

out vec4 fragColor;

const mat4 bias = mat4(0.5, 0.0, 0.0, 0.0,
                       0.0, 0.5, 0.0, 0.0,
                       0.0, 0.0, 0.5, 0.0,
                       0.5, 0.5, 0.5, 1.0);

vec3 fresnel(vec3 ior, vec3 color, vec3 v1, vec3 v2) {
    // http://seblagarde.wordpress.com/2012/06/03/spherical-gaussien-approximation-for-blinn-phong-phong-and-fresnel/
    // pow(..) = exp2(-8.35 * dot(v1, v2))
    vec3 F0 = abs ((1.0 - ior) / (1.0 + ior));
    F0 = F0 * F0;
    F0 = mix(F0, color, .5);
    return F0 + (1 - F0) * pow((1 - dot(v1, v2)), 5);
}

void main() {
    vec2 st = gl_FragCoord.xy / vec2(800, 600);
    
    vec3 eye_coord = texture(p_tex, st).xyz;
    vec3 normal = texture(n_tex, st).xyz;
    vec3 world_coord = texture(w_tex, st).xyz;

    vec4 shadow_coord = bias * light_view * vec4(world_coord, 1.0);
    
    vec3 Lo = vec3(0);
    
    if (lights[0].is_local) {
        vec3 L = normalize(lights[0].pos - eye_coord);
        vec3 V = normalize(camera - eye_coord);
        vec3 H = normalize(L + V);
        
        float cosH = clamp(dot(H, normal), 0, 1);
        float cosI = clamp(dot(normal, L), 0, 1);
        
        float r = length(lights[0].pos - eye_coord);
        float attenuation = 1.0 / (lights[0].constant_attenuation
                                   + lights[0].linear_attenuation * r
                                   + lights[0].quadratic_attenuation * r * r);
        
        vec3 irr = lights[0].irradiance * attenuation;
        
        if (lights[0].is_spot) {
            float cosS = dot(normalize(lights[0].dir), L);
            float cosU = lights[0].spot_umbra;
            float cosP = lights[0].spot_penumbra;
            
            if (cosU < cosS && cosS < cosP)
                irr = irr * pow ((cosS - cosU) / (cosP - cosU), lights[0].spot_exp);
            
            if (cosS <= cosU)
                irr = vec3(0.0);
        }
        
        float shadow = 0.0;
        shadow += textureProjOffset(shadow_map, shadow_coord, ivec2(-1,  1));
        shadow += textureProjOffset(shadow_map, shadow_coord, ivec2( 1,  1));
        shadow += textureProjOffset(shadow_map, shadow_coord, ivec2(-1, -1));
        shadow += textureProjOffset(shadow_map, shadow_coord, ivec2( 1, -1));
        float f = shadow / 4.0;
        
        Lo += lights[0].ambient * material.ambient * attenuation;
        Lo += f * (lights[0].color * material.kd
                   + material.ks * pow(cosH, material.shininess) * fresnel(vec3(.47), material.specular, L, H))
                * irr * cosI;
    }

    fragColor = vec4(vec3(Lo), 1.0);
}