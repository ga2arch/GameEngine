#version 330

const int MAX_LIGHTS = 10;

in VS_FS_INTERFACE {
    
    vec3 world_coord;
    vec3 eye_coord;
    vec4 shadow_coord[MAX_LIGHTS];
    vec3 normal;
    
} fragment;

uniform sampler2DShadow shadow_map[MAX_LIGHTS];

uniform vec3 camera;
uniform int lights_num;

uniform vec3 light_pos[MAX_LIGHTS];
uniform vec3 light_dir[MAX_LIGHTS];

out vec4 fragColor;
 
void main() {
    vec3 diff = vec3(.5, .8, .3);
    vec3 spec = vec3(1,1,1);
    vec3 irr = vec3(45);
    float m = 40;
   
    vec3 Lo = vec3(.1,.1,.1);
    for (int i=0; i < lights_num; i++) {
        
        vec3 L = normalize(light_pos[i] - fragment.eye_coord);
        vec3 V = normalize(camera - fragment.eye_coord);
        vec3 H = normalize(L + V);
        
        float cosH = clamp(dot(H, fragment.normal), 0, 1);
        float cosI = clamp(dot(fragment.normal, L), 0, 1);
        
        float cosS = dot(normalize(light_dir[i]), L);
        float cosU = cos(50 * 0.01745);
        float cosP = cos(30 * 0.01745);
        
        float r = length(light_pos[i] - fragment.eye_coord);
        irr = irr / (r);
        
        if (cosU < cosS && cosS < cosP)
            irr = irr * pow ((cosS - cosU) / (cosP - cosU), 2.0);
    
        if (cosS <= cosU)
            irr = vec3(0.0);
        
        float shadow = 0.0;
        shadow += textureProjOffset(shadow_map[i], fragment.shadow_coord[i], ivec2(-1,  1));
        shadow += textureProjOffset(shadow_map[i], fragment.shadow_coord[i], ivec2( 1,  1));
        shadow += textureProjOffset(shadow_map[i], fragment.shadow_coord[i], ivec2(-1, -1));
        shadow += textureProjOffset(shadow_map[i], fragment.shadow_coord[i], ivec2( 1, -1));
        float f = shadow / 4.0;
    
        Lo += (diff/3.14 + (m+8)/(3.14*8) * pow(cosH, m)*spec) * irr * cosI;
        Lo *= f;
    }

    fragColor = vec4(Lo, 1.0);
}