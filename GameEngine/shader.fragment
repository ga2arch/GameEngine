#version 330

const int MAX_LIGHTS = 10;

in VS_FS_INTERFACE {
    
    vec3 world_coord;
    vec3 eye_coord;
    vec4 shadow_coord[MAX_LIGHTS];
    vec3 normal;
    
} fragment;

uniform sampler2DShadow shadow_map[MAX_LIGHTS];

uniform vec3 camera;
uniform int lights_num;

struct LightProperty {
    bool is_enabled;
    bool is_local;
    bool is_spot;
    
    vec3 pos;
    vec3 dir;
    vec3 ambient;
    vec3 color;
    vec3 half_vector;
    
    vec3 irradiance;
    float spot_cos_cutff;
    float spot_exp;
    float constant_attenuation;
    float linear_attenuation;
    float quadratic_attenuation;
};

struct MaterialProperty {
    vec3 emission;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
    
    vec3 kd;
    float ks;
};

uniform LightProperty lights[MAX_LIGHTS];
uniform MaterialProperty material;

out vec4 fragColor;

vec3 fresnel(vec3 v1, vec3 v2, vec3 color) {
    // http://seblagarde.wordpress.com/2012/06/03/spherical-gaussien-approximation-for-blinn-phong-phong-and-fresnel/
    // pow(..) = exp2(-8.35 * dot(v1, v2))
    return color + (1 - color) * pow((1 - dot(v1, v2)), 5);
}

void main() {
    vec3 Lo = vec3(0);
    
    for (int i=0; i < lights_num; i++) {
        
        if (!lights[i].is_enabled) continue;
    
        if (lights[i].is_local) {
            vec3 L = normalize(lights[i].pos - fragment.eye_coord);
            vec3 V = normalize(camera - fragment.eye_coord);
            vec3 H = normalize(L + V);
            
            float cosH = clamp(dot(H, fragment.normal), 0, 1);
            float cosI = clamp(dot(fragment.normal, L), 0, 1);
            
            float r = length(lights[i].pos - fragment.eye_coord);
            float attenuation = 1.0 / (lights[i].constant_attenuation
                                       + lights[i].linear_attenuation * r
                                       + lights[i].quadratic_attenuation * r * r);
            
            vec3 irr = lights[i].irradiance * attenuation;
            
            if (lights[i].is_spot) {
                float cosS = dot(normalize(lights[i].dir), L);
                float cosU = cos(80 * 0.01745);
                float cosP = cos(70 * 0.01745);
                
                if (cosU < cosS && cosS < cosP)
                    irr = irr * pow ((cosS - cosU) / (cosP - cosU), lights[i].spot_exp);
                
                if (cosS <= cosU)
                    irr = vec3(0.0);
            }
            
            float shadow = 0.0;
            shadow += textureProjOffset(shadow_map[i], fragment.shadow_coord[i], ivec2(-1,  1));
            shadow += textureProjOffset(shadow_map[i], fragment.shadow_coord[i], ivec2( 1,  1));
            shadow += textureProjOffset(shadow_map[i], fragment.shadow_coord[i], ivec2(-1, -1));
            shadow += textureProjOffset(shadow_map[i], fragment.shadow_coord[i], ivec2( 1, -1));
            float f = shadow / 4.0;
            
            
            Lo += lights[i].ambient * material.ambient * attenuation;
            Lo += f * (lights[i].color * material.kd
                       + material.ks * pow(cosH, material.shininess) * fresnel(material.specular, L, H))
                    * irr * cosI;
        }
    }

    
    fragColor = vec4(vec3(Lo), 1.0);
}