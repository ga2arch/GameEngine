#version 330

struct LightProperty {
    bool is_enabled;
    bool is_local;
    bool is_spot;
    
    vec3 pos;
    vec3 dir;
    vec3 ambient;
    vec3 color;
    vec3 half_vector;
    
    vec3 irradiance;
    float spot_umbra;
    float spot_penumbra;
    float spot_exp;
    float constant_attenuation;
    float linear_attenuation;
    float quadratic_attenuation;
};

struct MaterialProperty {
    vec3 emission;
    vec3 ambient;
    vec3 diffuse;
    vec3 specular;
    float shininess;
    
    vec3 kd;
    float ks;
};

uniform LightProperty lights[10];
uniform MaterialProperty material;
uniform vec3 camera;

uniform sampler2D p_tex;
uniform sampler2D n_tex;

out vec4 fragColor;

vec3 fresnel(vec3 ior, vec3 color, vec3 v1, vec3 v2) {
    // http://seblagarde.wordpress.com/2012/06/03/spherical-gaussien-approximation-for-blinn-phong-phong-and-fresnel/
    // pow(..) = exp2(-8.35 * dot(v1, v2))
    vec3 F0 = abs ((1.0 - ior) / (1.0 + ior));
    F0 = F0 * F0;
    F0 = mix(F0, color, .5);
    return F0 + (1 - F0) * pow((1 - dot(v1, v2)), 5);
}

void main() {
    vec3 eye_coord = texture(p_tex, vec2(gl_FragCoord.x/800, gl_FragCoord.y/600)).xyz;
    vec3 normal = texture(n_tex, vec2(gl_FragCoord.x/800, gl_FragCoord.y/600)).xyz;
    
    vec3 Lo = vec3(0);
    int i = 0;
    //for (int i=0; i < lights_num; i++) {
        
        //if (!lights[i].is_enabled) continue;
    
        //if (lights[i].is_local) {
            vec3 L = normalize(lights[i].pos - eye_coord);
            vec3 V = normalize(camera - eye_coord);
            vec3 H = normalize(L + V);
            
            float cosH = clamp(dot(H, normal), 0, 1);
            float cosI = clamp(dot(normal, L), 0, 1);
            
            float r = length(lights[i].pos - eye_coord);
            float attenuation = 1.0 / (lights[i].constant_attenuation
                                       + lights[i].linear_attenuation * r
                                       + lights[i].quadratic_attenuation * r * r);
            
            vec3 irr = lights[i].irradiance * attenuation;
            
//            if (lights[i].is_spot) {
//                float cosS = dot(normalize(lights[i].dir), L);
//                float cosU = lights[i].spot_umbra;
//                float cosP = lights[i].spot_penumbra;
//                
//                if (cosU < cosS && cosS < cosP)
//                    irr = irr * pow ((cosS - cosU) / (cosP - cosU), lights[i].spot_exp);
//                
//                if (cosS <= cosU)
//                    irr = vec3(0.0);
//            }
            float f = 1;
            
            Lo += lights[i].ambient * material.ambient * attenuation;
            Lo += f * (lights[i].color * material.kd
                       + material.ks * pow(cosH, material.shininess) * fresnel(vec3(.47), material.specular, L, H))
                    * irr * cosI;
        //}
    //}

    
    fragColor = vec4(vec3(V), 1.0);
}