#version 330

in VS_FS_INTERFACE {
    
    vec3 world_coord;
    vec3 eye_coord;
    vec4 shadow_coord;
    vec3 normal;
    
} fragment;

uniform sampler2DShadow shadow_map;

uniform vec3 camera;

uniform vec3 light_pos[2];
uniform vec3 light_dir[2];

out vec4 fragColor;
 
void main() {
    vec3 diff = vec3(.5, .8, .3);
    vec3 spec = vec3(1,1,1);
    vec3 irr = vec3(45);
    float m = 40;
   
    vec3 Lo = vec3(.1,.1,.1);
    
    int i = 1;
    //for (int i=0; i < 2; i++) {
        
        vec3 L = normalize(light_pos[i] - fragment.eye_coord);
        vec3 V = normalize(camera - fragment.eye_coord);
        vec3 H = normalize(L + V);
        
        float cosH = clamp(dot(H, fragment.normal), 0, 1);
        float cosI = clamp(dot(fragment.normal, L), 0, 1);
        
        float cosS = dot(normalize(light_dir[i]), L);
        float cosU = cos(50 * 0.01745);
        float cosP = cos(30 * 0.01745);
        
        float r = length(light_pos[i] - fragment.eye_coord);
        irr = irr / (r);
        //
        //    if (cosU < cosS && cosS < cosP)
        //        irr = irr * pow ((cosS - cosU) / (cosP - cosU), 2.0);
        //
        //    if (cosS <= cosU)
        //        irr = vec3(0.0);
        
        float shadow = 0.0;
        shadow += textureProjOffset(shadow_map, fragment.shadow_coord, ivec2(-1,  1));
        shadow += textureProjOffset(shadow_map, fragment.shadow_coord, ivec2( 1,  1));
        shadow += textureProjOffset(shadow_map, fragment.shadow_coord, ivec2(-1, -1));
        shadow += textureProjOffset(shadow_map, fragment.shadow_coord, ivec2( 1, -1));
        float f = shadow / 4.0;
        
        Lo += (diff/3.14 + (m+8)/(3.14*8) * pow(cosH, m)*spec) * irr * cosI;
        Lo *= f;
    //}

    fragColor = vec4(Lo, 1.0);
}